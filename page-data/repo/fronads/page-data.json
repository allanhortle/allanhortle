{"componentChunkName":"component---src-pages-repo-fronads-mdx","path":"/repo/fronads/","webpackCompilationHash":"b3936b1a61b70176530d","result":{"data":{"readme":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Fronads\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/fronads\"\n  }), mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"src\": \"https://img.shields.io/npm/v/fronads.svg?style=flat-square\",\n    \"alt\": \"fronads npm\"\n  })))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Frontend monads with consistent and beginner-friendly naming conventions. \")), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://blueflag.github.io/fronads/\"\n  }), \"docs\")), mdx(\"h3\", null, \"What is a monad?\"), mdx(\"p\", null, \"Monads are function composers. They let you compose functions together to control your program flow.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monads let you map a function to a value. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Monads are only ever in one state at a time. Each of their methods returns either the same monad or a new one in a different state. \")), mdx(\"h3\", null, \"Almost monads\"), mdx(\"p\", null, \"Monads are a specific combination of ideas that you probably already understand. Because of this it can be hard to understand the whole but easy to grasp the parts. \"), mdx(\"p\", null, \"Some almost monad things to help you understand:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Promises are almost monads\"), \": They provide a consistent interface to structure the flow of async data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Promises are almost monads\"), \": They can only ever be in one state at a time. Resolved, Rejected.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Arrays are almost monads\"), \": They can always have a function mapped to their value, regardless of what they contain. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Array.map is almost monadic\"), \": It provides a level of immutability by returning a new array with the values changed.\")), mdx(\"h3\", null, \"All monads\"), mdx(\"p\", null, \"All monads have these three methods. Some languages have different names for them, but their idea remains the same.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unit \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"flatMap \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"map\")), mdx(\"h3\", null, \"Unit\"), mdx(\"p\", null, \"Unit is the monad constructor. It takes a value and returns a new monad of that state.\\nBecause monads deal with program flow and most monads have sort of sub types that represent one or more the states. The Unit's purpose is to let you declare a single monad of a specific state. E.g.\"), mdx(\"p\", null, \"Some/None\\nLeft/Right\\nFetching/Error/Success\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"js\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-js\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"unitExample\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"{\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token keyword\"\n  }), \"return\"), \" test \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token operator\"\n  }), \"?\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"Some\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), \"value\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \":\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token function\"\n  }), \"None\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"(\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \")\"), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \";\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"token punctuation\"\n  }), \"}\")))), mdx(\"p\", null, \"The above function is consistent because it always returns a monad. However if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test\"), \" is true it will return a\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Some\"), \" monad containing a value, otherwise it will return a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"None\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"9/10 times you'd use the specific unit constructor for the monad you want but each monad does have a \", mdx(\"inlineCode\", {\n    parentName: \"em\"\n  }, \".unit\"), \" method\")), mdx(\"h3\", null, \"flatMap\"), mdx(\"p\", null, \"The second core function of a monad is Flatmap. It's not however the flatter version of map, in fact flatMap provideds the basis for map.\\nFlatmap says I'll pass the current value to your function, you return me another monad. \"), mdx(\"p\", null, \"Other terms: bind, chain\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Fronads chooses flatMap/map because they pair nicely.\")), mdx(\"h3\", null, \"map\"), mdx(\"p\", null, \"Map builds off both unit and Flatmap, and  is essentially \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value => flatMap(Unit(value))\"), \".\\nMap is a convenient flatMap. It knows that you probably want the same monad again and so automatically creates the one you want. Letting you do things like:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", _extends({\n    parentName: \"div\"\n  }, {\n    \"className\": \"language-text\"\n  }), mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"Some(person).map(person => person.age) \"))), mdx(\"p\", null, \"The above statement will return a new some containing the persons age. \"));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":true,"frontmatter":{}}}}