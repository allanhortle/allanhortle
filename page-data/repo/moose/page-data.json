{"componentChunkName":"component---src-pages-repo-moose-mdx","path":"/repo/moose/","webpackCompilationHash":"b3936b1a61b70176530d","result":{"data":{"readme":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"introduction\",\n  \"title\": \"Introduction\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Why\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unidirectional rendering frameworks have given developers the ability to modularise code bases. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The prevailing methodology seems to be small dumb components and large smart components.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This split is too naive and in practice it doesn't create a meaningful abstraction. Codebases end\\nup with a tiny amount of small reusable 'dumb' components and a large amount of monolithic\\napplication specific 'smart' components.\")), mdx(\"p\", null, \"What the front-end really needs is a way to talk about interfaces that effectively separates its concerns. \"), mdx(\"h2\", null, \"Core Ideas\"), mdx(\"p\", null, \"Moose aims to provide clear descriptions of the parts that make up a client-side application.\\nIf we can describe these parts correctly it becomes easy to label and categorise the areas of our\\napps. Once categorised, code structure and responsibility becomes easier to define.\"), mdx(\"h2\", null, \"Clientside Concerns\"), mdx(\"p\", null, \"The client side code has six clear areas of concern:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Data fetching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Data Storage\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Application logic\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"User Interaction Logic\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Positional Styles (Layout)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Aesthetic Styles (Component Styles)\")), mdx(\"p\", null, \"_Broadly speaking you can split these six areas of concern into two main layers. Application and\\nInteraction. Application is concerned with data and how it is stored and transformed to render.\\nInteraction is concerned with how things look and feel and how the user interacts with them.\"), mdx(\"p\", null, \"The interaction layer is general and naturally lends itself to abstraction. The application layer is\\nspecific and tends to describe concrete implementations._\"), mdx(\"h2\", null, \"Application Layer\"), mdx(\"h3\", null, \"Data Fetching\"), mdx(\"p\", null, \"This concern describes how data from exterior sources makes it's way into the application. \"), mdx(\"h3\", null, \"Data Storage\"), mdx(\"p\", null, \"Often labelled as state management, data storage describes how external data is stored in memory\\nthroughout your app.\"), mdx(\"h3\", null, \"Application Logic\"), mdx(\"p\", null, \"Like business logic in a backend, application logic is the specific ways that data is transformed\\nand applied to your interfaces. Taking a collection of users and applying their attributes to a\\ntable is application logic. In a unique location you have decided that these users are best\\ndisplayed as a table and this is how you transform the data into the shape a table requires.\"), mdx(\"h2\", null, \"Interaction Layer\"), mdx(\"h3\", null, \"Interaction Logic\"), mdx(\"p\", null, \"Distinct to application logic, interaction logic is the specific ways the user interacts with parts\\nof the site. When a user types in a search box and a list of possible choices appears, that is\\ninteraction logic. Some part of the app is concerned with what the user has typed and what possible\\nchoices it could show in response. It is a separate concern from application logic because it\\ndoesn't care what data it is given or where it came from, just how that data should respond to the\\nusers interaction. \"), mdx(\"h3\", null, \"Aesthetic Styles\"), mdx(\"p\", null, \"Aesthetic styles describe how your individual components should look. Libraries and methodologies,\\nlike Bootstrap, Atomic Design etc. have got this right. You can describe all possible states of a\\nbutton quite clearly and all the code required to define how a button looks should be separate from\\nother parts of your app.\"), mdx(\"h3\", null, \"Positional Styles\"), mdx(\"p\", null, \"Positional styles describe how the different parts of your app relate to each other in position.\\nGrids, floats, text spacing all fall under this category. Component libraries often become bloated\\nand confused when positional styles are combined with aesthetic ones. Class names like\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".marginLeftLarge\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"paddingTopExtraSmall\"), \" become littered throughout the app, making things hard\\nto move and refactor. Positional styles are a unique concern and should be separate for other parts\\nof you app.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"pageContext":{"isCreatedByStatefulCreatePages":true,"frontmatter":{}}}}